import numpy as np
import torch.nn as nn
from torchvision import models

from config import *
from .metrics import ArcFace


class Alexnet(nn.Module):
    def __init__(self, args):
        super().__init__()

        # AlexNetの学習済みモデルをロード
        self.network = models.alexnet(pretrained=True)

        self.metric = args.metric

        alx_lt = list(self.network.classifier)
        if args.metric == 'arcface':
            # AlexNetのclassifierをarcfaceに変更する
            self.network.classifier = ArcFace(alx_lt[1].in_features, NUM_CLASS, s=30, m=0.5)
        else:
            # AlexNetの最終層の次元を変更する
            alx_lt[6] = nn.Linear(4096, NUM_CLASS, bias=True)
            self.network.classifier = nn.Sequential(alx_lt[0], alx_lt[1], alx_lt[2], alx_lt[3],
                                                    alx_lt[4], alx_lt[5], alx_lt[6])

        if args.model_use:
            model_path = '{}/{}_{}.pth'.format(MODEL_DIR, args.network, args.metric)
            self.network.load_state_dict(torch.load(model_path))

    def forward(self, x, labels):
        x = self.network.features(x)
        x = self.network.avgpool(x)
        features = torch.flatten(x, 1)
        if self.metric == 'softmax':
            outputs = self.network.classifier(features)
        else:
            outputs = self.network.classifier(features, labels)
        return outputs

    # 学習した特徴量を抽出する
    def extract_features(self, data_loaders, dl_type):
        self.network.eval()
        with torch.no_grad():
            features_list = []
            labels_list = []
            for data in data_loaders[dl_type]:
                images, labels = data

                images = images.to(DEVICE)
                labels = labels.to(DEVICE)

                x = self.network.features(images)
                x = self.network.avgpool(x)
                feature = torch.flatten(x, 1)

                feature = feature.cpu()
                features_list.append(feature)
                if dl_type == 'unknown':
                    labels = labels.cpu()
                    labels_list.append(labels)

        features = torch.cat(features_list, dim=0)

        if dl_type == 'unknown':
            labels = np.array(torch.cat(labels_list, dim=0))
            labels = np.where((labels == 3) | (labels == 4), 1, -1)
        else:
            labels = np.ones(len(features), int)

        return features, labels
