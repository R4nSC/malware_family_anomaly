import torch
import numpy as np
from torch.autograd import Variable
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

from visualization import *
from config import *


# 分類タスクのテスト
def classification_test(args, f_model, m_model, data_loaders, datasets_size):
    total = 0
    all_pred = torch.zeros(1)
    all_label = torch.zeros(1)

    f_model.eval()
    m_model.eval()
    with torch.no_grad():
        for data in data_loaders['test']:
            images, labels = data

            images = images.to(DEVICE)
            labels = labels.to(DEVICE)
            all_pred = all_pred.to(DEVICE)
            all_label = all_label.to(DEVICE)

            features = f_model(images)
            if args.metric == 'softmax':
                outputs = m_model(features)
            else:
                outputs = m_model(features, labels)
            _, predicted = torch.max(outputs.data, 1)
            if total == 0:
                all_pred = predicted
                all_label = labels
            else:
                all_pred = torch.cat((all_pred, predicted), 0)
                all_label = torch.cat((all_label, labels), 0)

            total = all_label.size(0)

    # 分類精度の計算
    total = all_label.size(0)
    correct = (all_pred == all_label).sum().item()

    # 混同行列の可視化
    if args.gui:
        multi_classification_result_visualization(all_label, all_pred)

    # 分類精度の出力
    print('Accuracy of the network on the {:d} test images: {:.4f}'.format(datasets_size['test'], correct / total))


# 異常検知タスクのテスト
def anomaly_detection_test(args, features_model, anomaly_model, data_loaders, datasets_size):
    # 評価データセットと未知データセットそれぞれのEmbeddingデータセットを作成
    test_features = features_model.extract_features(data_loaders['test'])
    unknown_features = features_model.extract_features(data_loaders['unknown'])

    # Embeddingデータセットをt-SNEを利用して可視化する
    if args.gui:
        embedding_tsne_visualization(test_features, unknown_features)

    # 既知の評価データセットを予測して検知精度を出力
    pred_test = anomaly_model.predict(test_features)

    pos_total = test_features.size(0)
    pos_correct = (pred_test == 1).sum().item()
    pos_incorrect = (pred_test == -1).sum().item()

    print('total = {:d}, correct = {:d}, incorrect = {:d}'.format(pos_total, pos_correct, pos_incorrect))
    print('Accuracy of anomaly detection on the {:d} known test images: {:.4f}'.format(datasets_size['test'],
                                                                                       pos_correct / pos_total))

    # 未知の評価データセットを予測して検知精度を出力
    pred_unknown = anomaly_model.predict(unknown_features)

    neg_total = unknown_features.size(0)
    neg_correct = (pred_unknown == -1).sum().item()
    neg_incorrect = (pred_unknown == 1).sum().item()

    print(pred_unknown)

    print('total = {:d}, correct = {:d}, incorrect = {:d}'.format(neg_total, neg_correct, neg_incorrect))
    print('Accuracy of anomaly detection on the {:d} unknown test images: {:.4f}'.format(datasets_size['unknown'],
                                                                                         neg_correct / neg_total))

    # 二値分類の混同行列作成用の予測ラベルベクトルを作成
    pred = np.concatenate([pred_test, pred_unknown], 0)

    # 二値分類の混同行列作成用の正解ラベルベクトルを作成
    label_pos = np.ones(pos_total, int)
    label_neg = np.full(neg_total, -1)
    label = np.concatenate([label_pos, label_neg], 0)

    # 二値分類の混同行列を出力
    if args.gui:
        Binary_classification_result_visualization(pred, label)
