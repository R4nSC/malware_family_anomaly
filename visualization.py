import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.metrics import confusion_matrix
import torchvision


# 画像の表示
def image_show(img):
    img = img / 2 + 0.5
    np_img = img.numpy()
    plt.imshow(np.transpose(np_img, (1, 2, 0)))
    plt.show()


# マルウェアの画像化(前処理等)のデバッグ
def malware_image_debug(data_loaders, class_names):
    # 訓練データをランダムに取得
    data_iter = iter(data_loaders["train"])
    images, labels = data_iter.next()

    # 画像の表示
    image_show(torchvision.utils.make_grid(images))
    # ラベルの表示
    print(' '.join('%5s' % class_names['known'][labels[j]] for j in range(8)))


# 学習の可視化
def train_visualization(loss, acc, epoch):
    # 学習の可視化
    loss_train = loss["train"]
    loss_val = loss["val"]

    acc_train = acc["train"]
    acc_val = acc["val"]

    # このように書く事で、nrows x cols のグラフを作成する事ができます。
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 5))

    # ０個目のグラフ
    axes[0].plot(range(epoch), loss_train, label="train")
    axes[0].plot(range(epoch), loss_val, label="val")
    axes[0].set_title("Loss")
    axes[0].legend()  # 各グラフのlabelを表示

    # １個目のグラフ
    axes[1].plot(range(epoch), acc_train, label="train")
    axes[1].plot(range(epoch), acc_val, label="val")
    axes[1].set_title("Train Loss")
    axes[1].legend()

    # ０個目と１個目のグラフが重ならないように調整
    fig.tight_layout()

    # 出力
    plt.show()


# 多クラス分類の結果(混同行列)を可視化
def multi_classification_result_visualization(true_labels, pred_labels):
    # 混同行列に付与するラベルの取得
    labels = true_labels.to('cpu').detach().numpy().copy()
    labels = sorted(list(set(labels)))

    # 混同行列の計算
    df = pd.DataFrame(confusion_matrix(true_labels, pred_labels), index=labels, columns=labels)

    # GUIへの出力
    plt.figure()
    sns.heatmap(df, annot=True)  # annot = Falseにすると図中の各セルの数値表示がなくなる。
    plt.show()
